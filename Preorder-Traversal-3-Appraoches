//Recursive Approches

class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
      List<Integer> ans = new ArrayList<>();
      if(root == null)
          return ans;
      preorder(root, ans);
      return ans;
  }
  static void preorder(TreeNode root, List<Integer> ans){
      if(root == null)
          return;
        ans.add(root.data);
        preorder(root.left);
        preorder(root.right);
      }
  }


//Iterative Appraoch
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        Stack<TreeNode> q = new Stack<>();
        List<Integer> ans = new ArrayList<>();
        TreeNode curr = root;
        while(true){
            if(curr != null){
                ans.add(curr.val);
                q.push(curr);
                curr = curr.left;
            }
            else{
                if(q.isEmpty())
                    break;
                curr = q.peek();
                curr = curr.right;
                q.pop();
                
            }
        }
        return ans;
    }
}


//using morris traversal
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> preorder = new ArrayList<>();
        TreeNode curr = root;
        while(curr != null){
            if(curr.left == null){
                inorder.add(curr.val);
                curr = curr.right;
            }
            else{
                TreeNode prev = curr.left;
                
                while(prev.right != null && prev.right != curr)
                    prev = prev.right;
                
                if(prev.right == null){
                    prev.right = curr;
                    preorder.add(curr.val);
                    curr = curr.left;
                }
               else{
                prev.right = null;
                curr = curr.right;
               }
           }
        }
        return preorder;
    }
}
