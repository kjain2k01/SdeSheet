
//Recursive Approach
//O(n)
class Solution{
public List<Integer> inorderTraversal(TreeNode root){
  if(root == null)
    return new ArrayList<Integer>();
   List<Integer> ans = new ArrayList<Integer>();
   inorder(root, ans);
   return ans;
   }
   
   static void inorder(TreeNode root, List<Integer> ans){
      if(root == null)
          return;
      
      inorder(root.left, ans);
      ans.add(root.val);
      inorder(root.right, ans);
   }
}

//using stack
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        TreeNode curr = root;
        List<Integer> ans = new ArrayList<>();
        Stack<TreeNode> st = new Stack<>();
       
        while(true){
            if(curr != null){
                st.push(curr);
                curr = curr.left;
            }
            else
            {
                if(st.isEmpty())
                    break;
                curr = st.peek();
                ans.add(curr.val);
                st.pop();
                curr = curr.right;
            }
        }
        return ans;
    }
    
    
//using morris traversal
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> inorder = new ArrayList<>();
        TreeNode curr = root;
        while(curr != null){
            if(curr.left == null){
                inorder.add(curr.val);
                curr = curr.right;
            }
            else{
                TreeNode prev = curr.left;
                
                while(prev.right != null && prev.right != curr)
                    prev = prev.right;
                
                if(prev.right == null){
                    prev.right = curr;
                    curr = curr.left;
                }
               else{
                prev.right = null;
                inorder.add(curr.val);
                curr = curr.right;
               }
           }
        }
        return inorder;
    }
}
